//
// Created by chris on 18-7-12.
//
/**
 * @brief a header file with definition for BaseInference class
 * @file inference.h
 */
#ifndef SAMPLES_DETECTION_H
#define SAMPLES_DETECTION_H

#include "validated_network.h"
#include "engine.h"
#include "result.h"
#include "output.h"
#include "opencv2/opencv.hpp"
#include "inference_engine.hpp"
#include "samples/common.hpp"
#include "samples/slog.hpp"
#include <memory>

namespace openvino_service {
/**
 * @class BaseInference
 * @brief base class for network inference.
 */
class BaseInference {
 public:
  explicit BaseInference();
  virtual ~BaseInference();
  /**
   * @brief load the Engine instance that contains the request for 
   * running netwrok on target calculation device.
   */
  void loadEngine(std::shared_ptr<NetworkEngine> engine);
  /**
   * @brief Get the loaded Engine instance.
   */
  inline const std::shared_ptr<NetworkEngine> getEngine() const {
    return engine_;
  }
  /**
   * @brief Get the number of enqueued frames to be infered.
   */
  inline const int getEnqueuedNum() const { return enqueued_frames; }
  /**
   * @brief Enqueue a frame to this class. 
   * The frame will be buffered but not infered yet.
   * @param[in] frame The frame to be enqueued.
   * @param[in] input_frame_loc The location of the enqueued frame with respect
   * to the frame generated by the input device.
   * @return whether this operation is successful.
   */
  virtual bool 
  enqueue(const cv::Mat &frame, const cv::Rect & input_frame_loc) = 0;
  /**
   * @brief Start inference for all buffered frames.
   * @return whether this operation is successful.
   */
  virtual bool submitRequest();
  /**
   * @brief This function will fetch the results of the previous inference and
   * stores the results in a result buffer array. All buffered frames will be 
   * cleared.
   * @return whether the Inference object fetches a result this time
   */
  virtual bool fetchResults();
  /**
   * @brief Accepts an Output instance for result process. This function is
   * used for visitor pattern.
   */
  virtual void accepts(std::shared_ptr<BaseOutput> output_visitor) = 0;
  /**
   * @brief Get the length of the buffer result array.
   */
  virtual const int getResultsLength() const = 0;
  /**
   * @brief Get the location of result with respect
   * to the frame generated by the input device.
   * @param[in] idx The index of the result.
   */
  virtual const InferenceResult::Result
  getLocationResult(int idx) const = 0;
  /**
   * @brief Get the name of the Inference instance.
   */
  virtual const std::string getName() const = 0;

 protected:
 /**
   * @brief Enqueue the fram into the input blob of the target calculation
   * device. Check OpenVINO document for detailed information.
   */
  template <typename T>
  bool enqueue(const cv::Mat &frame, const cv::Rect &, float, int,
               const std::string&);
  /**
   * @brief Set the max batch size for one inference.
   */             
  inline void setMaxBatchSize(int max_batch_size) {
    max_batch_size_ = max_batch_size;
  }

 private:
  std::shared_ptr<NetworkEngine> engine_;
  int max_batch_size_ = 1;
  int enqueued_frames = 0;
  bool results_fetched_ = false;
};

//Face Detection
class FaceDetection : public BaseInference {
 public:
  using Result = InferenceResult::FaceDetectionResult;
  explicit FaceDetection(int, int, double);
  ~FaceDetection() override ;
  void loadNetwork(std::shared_ptr<ValidatedFaceDetectionNetwork>);
  bool enqueue(const cv::Mat &, const cv::Rect &) override;
  bool submitRequest() override;
  bool fetchResults() override;
  void accepts(std::shared_ptr<BaseOutput> output_visitor) override ;
  const int getResultsLength() const override;
  const InferenceResult::Result
  getLocationResult(int idx) const override ;
  const std::string getName() const override;

 private:
  std::shared_ptr<ValidatedFaceDetectionNetwork> valid_network_;
  std::vector<Result> results_;
  int width_ = 0;
  int height_ = 0;
  int max_proposal_count_;
  int object_size_;
  double show_output_thresh_ = 0;
};

//Emotions Detection
class EmotionsDetection : public BaseInference {
 public:
  using Result = InferenceResult::EmotionsResult;
  explicit EmotionsDetection();
  ~EmotionsDetection() override ;
  void loadNetwork(std::shared_ptr<ValidatedEmotionsClassificationNetwork>);
  bool enqueue(const cv::Mat &, const cv::Rect &) override;
  bool submitRequest() override;
  bool fetchResults() override;
  void accepts(std::shared_ptr<BaseOutput> output_visitor) override ;
  const int getResultsLength() const override;
  const InferenceResult::Result
  getLocationResult(int idx) const override ;
  const std::string getName() const override;

 private:
  std::shared_ptr<ValidatedEmotionsClassificationNetwork> valid_network_;
  std::vector<Result> results_;
};

// AgeGender Detection
class AgeGenderDetection : public BaseInference {
 public:
  using Result = InferenceResult::AgeGenderResult;
  explicit AgeGenderDetection();
  ~AgeGenderDetection() override ;
  void loadNetwork(std::shared_ptr<ValidatedAgeGenderNetwork>);
  bool enqueue(const cv::Mat &frame, const cv::Rect &) override;
  bool submitRequest() override;
  bool fetchResults() override;
  void accepts(std::shared_ptr<BaseOutput> output_visitor) override ;
  const int getResultsLength() const override;
  const InferenceResult::Result
  getLocationResult(int idx) const override ;
  const std::string getName() const override ;

 private:
  std::shared_ptr<ValidatedAgeGenderNetwork> valid_network_;
  std::vector<Result> results_;
};

// Head Pose Detection
class HeadPoseDetection : public BaseInference {
 public:
  using Result = InferenceResult::HeadPoseResult;
  explicit HeadPoseDetection();
  ~HeadPoseDetection() override ;
  void loadNetwork(std::shared_ptr<ValidatedHeadPoseNetwork>);
  bool enqueue(const cv::Mat &frame, const cv::Rect &) override;
  bool submitRequest() override;
  bool fetchResults() override;
  void accepts(std::shared_ptr<BaseOutput> output_visitor) override ;
  const int getResultsLength() const override;
  const InferenceResult::Result
  getLocationResult(int idx) const override ;
  const std::string getName() const override ;

 private:
  std::shared_ptr<ValidatedHeadPoseNetwork> valid_network_;
  std::vector<Result> results_;
};
}

#endif //SAMPLES_DETECTION_H