\hypertarget{classInferenceEngine_1_1Extensions_1_1Cpu_1_1NormalizeImpl}{}\section{Inference\+Engine\+:\+:Extensions\+:\+:Cpu\+:\+:Normalize\+Impl Class Reference}
\label{classInferenceEngine_1_1Extensions_1_1Cpu_1_1NormalizeImpl}\index{Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Normalize\+Impl@{Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Normalize\+Impl}}


Inheritance diagram for Inference\+Engine\+:\+:Extensions\+:\+:Cpu\+:\+:Normalize\+Impl\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=222pt]{classInferenceEngine_1_1Extensions_1_1Cpu_1_1NormalizeImpl__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for Inference\+Engine\+:\+:Extensions\+:\+:Cpu\+:\+:Normalize\+Impl\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=234pt]{classInferenceEngine_1_1Extensions_1_1Cpu_1_1NormalizeImpl__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1NormalizeImpl_a45024d9af0dc5579efdc2b8660cb4c17}{Normalize\+Impl} (const C\+N\+N\+Layer $\ast$layer)
\item 
Status\+Code \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1NormalizeImpl_a912719712bd31cb88fbb02b884ee33c5}{execute} (std\+::vector$<$ Blob\+::\+Ptr $>$ \&inputs, std\+::vector$<$ Blob\+::\+Ptr $>$ \&outputs, Response\+Desc $\ast$resp) noexceptoverride
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}


Definition at line 30 of file ext\+\_\+normalize.\+cpp.



\subsection{Constructor \& Destructor Documentation}
\index{Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Normalize\+Impl@{Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Normalize\+Impl}!Normalize\+Impl@{Normalize\+Impl}}
\index{Normalize\+Impl@{Normalize\+Impl}!Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Normalize\+Impl@{Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Normalize\+Impl}}
\subsubsection[{\texorpdfstring{Normalize\+Impl(const C\+N\+N\+Layer $\ast$layer)}{NormalizeImpl(const CNNLayer *layer)}}]{\setlength{\rightskip}{0pt plus 5cm}Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Normalize\+Impl\+::\+Normalize\+Impl (
\begin{DoxyParamCaption}
\item[{const C\+N\+N\+Layer $\ast$}]{layer}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}\hypertarget{classInferenceEngine_1_1Extensions_1_1Cpu_1_1NormalizeImpl_a45024d9af0dc5579efdc2b8660cb4c17}{}\label{classInferenceEngine_1_1Extensions_1_1Cpu_1_1NormalizeImpl_a45024d9af0dc5579efdc2b8660cb4c17}


Definition at line 32 of file ext\+\_\+normalize.\+cpp.


\begin{DoxyCode}
32                                                  : \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_affff0e8263ca26852ccf71d299d7b06a}{ExtLayerBase}(layer) \{
33         \textcolor{keywordflow}{try} \{
34             \textcolor{keywordflow}{if} (\hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1074cdccacb9e9ca6eec01bbc2f7ca4a}{cnnLayer}.insData.size() != 1 || \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1074cdccacb9e9ca6eec01bbc2f7ca4a}{cnnLayer}.outData.size() != 1)
35                 THROW\_IE\_EXCEPTION << \textcolor{stringliteral}{"Incorrect number of input/output edges!"};
36 
37             weights = std::dynamic\_pointer\_cast<TBlob<float>>(\hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1074cdccacb9e9ca6eec01bbc2f7ca4a}{cnnLayer}.blobs[\textcolor{stringliteral}{"weights"}]);
38             \textcolor{keywordflow}{if} (!weights)
39                 THROW\_IE\_EXCEPTION << \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1074cdccacb9e9ca6eec01bbc2f7ca4a}{cnnLayer}.name << \textcolor{stringliteral}{" weights is empty!"};
40             across\_spatial = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(\hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1074cdccacb9e9ca6eec01bbc2f7ca4a}{cnnLayer}.GetParamAsInt(\textcolor{stringliteral}{"across\_spatial"}));
41             channel\_shared = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(\hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1074cdccacb9e9ca6eec01bbc2f7ca4a}{cnnLayer}.GetParamAsInt(\textcolor{stringliteral}{"channel\_shared"}));
42             eps = \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1074cdccacb9e9ca6eec01bbc2f7ca4a}{cnnLayer}.GetParamAsFloat(\textcolor{stringliteral}{"eps"});
43 
44             \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a0ac7a6632e95b9500d5246b05b4b0bfa}{addConfig}(\{\{\hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1258a8d209e0249e0b1717618352ddfba446687ea2db1ada75be5ed053be77f59}{ConfLayout::PLN}, \textcolor{keyword}{false}, 0\}\}, \{\{
      \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1258a8d209e0249e0b1717618352ddfba446687ea2db1ada75be5ed053be77f59}{ConfLayout::PLN}, \textcolor{keyword}{false}, 0\}\}, \textcolor{keyword}{true});
45         \} \textcolor{keywordflow}{catch} (InferenceEngine::details::InferenceEngineException &ex) \{
46             \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_abc78e9b5a79fa339ffd831a5318f71f7}{errorMsg} = ex.what();
47         \}
48     \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Normalize\+Impl@{Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Normalize\+Impl}!execute@{execute}}
\index{execute@{execute}!Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Normalize\+Impl@{Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Normalize\+Impl}}
\subsubsection[{\texorpdfstring{execute(std\+::vector$<$ Blob\+::\+Ptr $>$ \&inputs, std\+::vector$<$ Blob\+::\+Ptr $>$ \&outputs, Response\+Desc $\ast$resp) noexceptoverride}{execute(std::vector< Blob::Ptr > &inputs, std::vector< Blob::Ptr > &outputs, ResponseDesc *resp) noexceptoverride}}]{\setlength{\rightskip}{0pt plus 5cm}Status\+Code Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Normalize\+Impl\+::execute (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ Blob\+::\+Ptr $>$ \&}]{inputs, }
\item[{std\+::vector$<$ Blob\+::\+Ptr $>$ \&}]{outputs, }
\item[{Response\+Desc $\ast$}]{resp}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [noexcept]}}\hypertarget{classInferenceEngine_1_1Extensions_1_1Cpu_1_1NormalizeImpl_a912719712bd31cb88fbb02b884ee33c5}{}\label{classInferenceEngine_1_1Extensions_1_1Cpu_1_1NormalizeImpl_a912719712bd31cb88fbb02b884ee33c5}


Definition at line 72 of file ext\+\_\+normalize.\+cpp.


\begin{DoxyCode}
73                                                              \{
74         \textcolor{keywordflow}{if} (inputs.size() != 1 || outputs.empty()) \{
75             \textcolor{keywordflow}{if} (resp) \{
76                 std::string \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_abc78e9b5a79fa339ffd831a5318f71f7}{errorMsg} = \textcolor{stringliteral}{"Incorrect number of input or output edges!"};
77                 errorMsg.copy(resp->msg, \textcolor{keyword}{sizeof}(resp->msg) - 1);
78             \}
79             \textcolor{keywordflow}{return} GENERAL\_ERROR;
80         \}
81         \textcolor{keyword}{const} \textcolor{keywordtype}{float}* src = inputs[0]->buffer();
82         \textcolor{keyword}{const} \textcolor{keywordtype}{float}* scl = weights->buffer();
83         \textcolor{keywordtype}{float}* dst = outputs[0]->buffer();
84 
85         SizeVector dims = inputs[0]->getTensorDesc().getDims();
86 
87         \textcolor{keyword}{const} \textcolor{keywordtype}{int} N = \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{int}\textcolor{keyword}{>}(dims[0]);
88         \textcolor{keyword}{const} \textcolor{keywordtype}{int} C = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(dims[1]);
89         \textcolor{keyword}{const} \textcolor{keywordtype}{int} H = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(dims[2]);
90         \textcolor{keyword}{const} \textcolor{keywordtype}{int} W = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(dims[3]);
91 
92         \textcolor{keyword}{const} \textcolor{keywordtype}{int} HW = H*W;
93         \textcolor{keyword}{const} \textcolor{keywordtype}{int} CHW = C*HW;
94 
95         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} n = 0; n < N; n++) \{
96             \textcolor{keyword}{const} \textcolor{keywordtype}{float}* psrc = src + n*C*H*W;
97             \textcolor{keywordtype}{float}* pdst = dst + n*C*H*W;
98 
99             \textcolor{keywordflow}{if} (across\_spatial) \{
100                 \textcolor{keywordtype}{float} norm = eps;
101                 \textcolor{keywordtype}{int} i = 0;
102 \textcolor{preprocessor}{#if defined(HAVE\_AVX2)}
103                 \{
104                     \_\_m256 vsum = \_mm256\_setzero\_ps();
105                     \textcolor{keywordflow}{for} (; i <= C*H*W-8; i += 8) \{
106                         \_\_m256 vsrc = \_mm256\_loadu\_ps(psrc + i);
107                         vsum = \_mm256\_fmadd\_ps(vsrc, vsrc, vsum);
108                     \}
109                     norm += hsum\_avx2(vsum);
110                 \}
111 \textcolor{preprocessor}{#elif defined(HAVE\_SSE)}
112                 \{
113                     \_\_m128 vsum = \_mm\_setzero\_ps();
114                     \textcolor{keywordflow}{for} (; i <= C*H*W-4; i += 4) \{
115                         \_\_m128 vsrc = \_mm\_loadu\_ps(psrc + i);
116                         vsum = \_mm\_add\_ps(\_mm\_mul\_ps(vsrc, vsrc), vsum);
117                     \}
118                     norm += hsum\_sse(vsum);
119                 \}
120 \textcolor{preprocessor}{#endif}
121                 \textcolor{keywordflow}{for} (; i < C*H*W; i++) \{
122                     norm += psrc[i]*psrc[i];
123                 \}
124                 norm = 1.0f / std::sqrt(norm);
125 
126                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c} = 0 ; \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c} < C; \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}++) \{
127                     \textcolor{keywordtype}{int} hw = 0;
128 \textcolor{preprocessor}{#if defined(HAVE\_AVX2)}
129                     \_\_m256 vnorm\_avx = \_mm256\_set1\_ps(norm);
130                     \_\_m256 vscl\_avx = \_mm256\_set1\_ps(channel\_shared ? scl[0] : scl[
      \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}]);
131                     vnorm\_avx = \_mm256\_mul\_ps(vnorm\_avx, vscl\_avx);
132 
133                     \textcolor{keywordflow}{for} ( ; hw <= H*W - 8; hw += 8) \{
134                         \_\_m256 vsrc = \_mm256\_loadu\_ps(psrc + \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}*H*W + hw);
135                         \_mm256\_storeu\_ps(pdst + \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}*H*W+hw, \_mm256\_mul\_ps(vsrc, vnorm\_avx));
136                     \}
137 \textcolor{preprocessor}{#elif defined(HAVE\_SSE)}
138                     \_\_m128 vnorm\_sse = \_mm\_set1\_ps(norm);
139                     \_\_m128 vscl\_sse = \_mm\_set1\_ps(channel\_shared ? scl[0] : scl[
      \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}]);
140                     vnorm\_sse = \_mm\_mul\_ps(vnorm\_sse, vscl\_sse);
141 
142                     \textcolor{keywordflow}{for} ( ; hw <= H*W - 4; hw += 4) \{
143                         \_\_m128 vsrc = \_mm\_loadu\_ps(psrc + \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}*H*W + hw);
144                         \_mm\_storeu\_ps(pdst + \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}*H*W+hw, \_mm\_mul\_ps(vsrc, vnorm\_sse));
145                     \}
146 \textcolor{preprocessor}{#endif}
147                     \textcolor{keywordflow}{for} ( ; hw < H*W; hw++) \{
148                         \textcolor{keywordtype}{float} s = channel\_shared ? scl[0] : scl[\hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}];
149                         pdst[\hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}*H*W+hw] = psrc[\hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}*H*W+hw] * norm * s;
150                     \}
151                 \}
152             \} \textcolor{keywordflow}{else} \{
153                 \textcolor{keywordtype}{int} wh = 0;
154 \textcolor{preprocessor}{#if defined(HAVE\_AVX2)}
155                 \textcolor{keywordflow}{for} (; wh <= W*H - 8; wh += 8) \{
156                     \_\_m256 vnorm = \_mm256\_set1\_ps(eps);
157                     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c} = 0; \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c} < C; \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}++) \{
158                         \textcolor{keyword}{const} \textcolor{keywordtype}{float}* psrc\_c = psrc + \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}*W*H;
159                         \_\_m256 vsrc = \_mm256\_loadu\_ps(psrc\_c + wh);
160                         vnorm = \_mm256\_fmadd\_ps(vsrc, vsrc, vnorm);
161                     \}
162                     vnorm = \_mm256\_div\_ps(\_mm256\_set1\_ps(1.0f), \_mm256\_sqrt\_ps(vnorm));
163 
164                     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c} = 0; \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c} < C; \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}++) \{
165                         \textcolor{keyword}{const} \textcolor{keywordtype}{float}* psrc\_c = psrc + \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}*W*H;
166                         \textcolor{keywordtype}{float}* pdst\_c = pdst + \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}*W*H;
167 
168                         \_\_m256 vscl = \_mm256\_set1\_ps(channel\_shared ? scl[0] : scl[
      \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}]);
169 
170                         \_\_m256 vsrc = \_mm256\_loadu\_ps(psrc\_c + wh);
171                         \_\_m256 vdst = \_mm256\_mul\_ps(vsrc, vnorm);
172                         vdst = \_mm256\_mul\_ps(vdst, vscl);
173 
174                         \_mm256\_storeu\_ps(pdst\_c + wh, vdst);
175                     \}
176                 \}
177 \textcolor{preprocessor}{#elif defined(HAVE\_SSE)}
178                 \textcolor{keywordflow}{for} (; wh <= W*H - 4; wh += 4) \{
179                     \_\_m128 vnorm = \_mm\_set1\_ps(eps);
180                     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c} = 0; \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c} < C; \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}++) \{
181                         \textcolor{keyword}{const} \textcolor{keywordtype}{float}* psrc\_c = psrc + \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}*W*H;
182                         \_\_m128 vsrc = \_mm\_loadu\_ps(psrc\_c + wh);
183 
184                         vnorm = \_mm\_add\_ps(\_mm\_mul\_ps(vsrc, vsrc), vnorm);
185                     \}
186 
187                     vnorm = \_mm\_div\_ps(\_mm\_set1\_ps(1.0f), \_mm\_sqrt\_ps(vnorm));
188 
189                     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c} = 0; \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c} < C; \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}++) \{
190                         \textcolor{keyword}{const} \textcolor{keywordtype}{float}* psrc\_c = psrc + \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}*W*H;
191                               \textcolor{keywordtype}{float}* pdst\_c = pdst + \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}*W*H;
192 
193                         \_\_m128 vscl = \_mm\_set1\_ps(channel\_shared ? scl[0] : scl[
      \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}]);
194 
195                         \_\_m128 vsrc = \_mm\_loadu\_ps(psrc\_c + wh);
196                         \_\_m128 vdst = \_mm\_mul\_ps(vsrc, vnorm);
197                         vdst = \_mm\_mul\_ps(vdst, vscl);
198 
199                         \_mm\_storeu\_ps(pdst\_c + wh, vdst);
200                     \}
201                 \}
202 \textcolor{preprocessor}{#endif}
203                 \textcolor{keywordflow}{for} (; wh < W*H; wh++) \{
204                     \textcolor{keywordtype}{float} norm = eps;
205                     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c} = 0; \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c} < C; \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}++) \{
206                         \textcolor{keyword}{const} \textcolor{keywordtype}{float}* psrc\_c = psrc + \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}*W*H;
207                         norm += psrc\_c[wh]*psrc\_c[wh];
208                     \}
209 
210                     norm = 1.0f / std::sqrt(norm);
211 
212                     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c} = 0; \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c} < C; \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}++) \{
213                         \textcolor{keyword}{const} \textcolor{keywordtype}{float}* psrc\_c = psrc + \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}*W*H;
214                         \textcolor{keywordtype}{float}* pdst\_c = pdst + \hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}*W*H;
215 
216                         pdst\_c[wh] = channel\_shared ? (psrc\_c[wh] * norm * scl[0]) : (psrc\_c[wh] * norm * 
      scl[\hyperlink{CMakeCache_8txt_aac1d6a1710812201527c735f7c6afbaa}{c}]);
217                     \}
218                 \}
219             \}
220         \}
221         \textcolor{keywordflow}{return} OK;
222     \}
\end{DoxyCode}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
thirdparty/extension/\hyperlink{ext__normalize_8cpp}{ext\+\_\+normalize.\+cpp}\end{DoxyCompactItemize}
