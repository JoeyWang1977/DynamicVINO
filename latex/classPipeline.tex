\hypertarget{classPipeline}{}\section{Pipeline Class Reference}
\label{classPipeline}\index{Pipeline@{Pipeline}}


This class is a pipeline class that stores the topology of the input device, output device and networks and make inference.  




{\ttfamily \#include $<$pipeline.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classPipeline_a4f65be70dd15f3c0550f6768244098a6}{Pipeline} ()=default
\item 
bool \hyperlink{classPipeline_ad4e6ed704a4dc3df23488a9cf5cf2ae0}{add} (const std\+::string \&parent, const std\+::string \&name, std\+::shared\+\_\+ptr$<$ \hyperlink{classBaseInputDevice}{Base\+Input\+Device} $>$ input\+\_\+device)
\begin{DoxyCompactList}\small\item\em Add input device to the pipeline. \end{DoxyCompactList}\item 
bool \hyperlink{classPipeline_ad680458b60d24030e7fe17343ddb6fba}{add} (const std\+::string \&parent, const std\+::string \&name, std\+::shared\+\_\+ptr$<$ \hyperlink{classopenvino__service_1_1BaseInference}{openvino\+\_\+service\+::\+Base\+Inference} $>$ inference)
\begin{DoxyCompactList}\small\item\em Add inference network to the pipeline. \end{DoxyCompactList}\item 
bool \hyperlink{classPipeline_a0fea1a0e2a297420afcd1aef773148b6}{add} (const std\+::string \&parent, const std\+::string \&name, std\+::shared\+\_\+ptr$<$ \hyperlink{classBaseOutput}{Base\+Output} $>$ output)
\begin{DoxyCompactList}\small\item\em Add output device to the pipeline. \end{DoxyCompactList}\item 
bool \hyperlink{classPipeline_a92f954c069e1355df63f753a656ac3ec}{add} (const std\+::string \&parent, const std\+::string \&name)
\begin{DoxyCompactList}\small\item\em Add inference network-\/output device edge to the pipeline. \end{DoxyCompactList}\item 
void \hyperlink{classPipeline_a5a2faba72449251db99090c4eaad3e1c}{run\+Once} ()
\begin{DoxyCompactList}\small\item\em Do the inference once. Data flow from input device to inference network, then to output device. \end{DoxyCompactList}\item 
void \hyperlink{classPipeline_ab65d4eafa6081d0eb3daddb372cc04dc}{callback} (const std\+::string \&detection\+\_\+name)
\begin{DoxyCompactList}\small\item\em The callback function provided for all the inference network in the pipeline. \end{DoxyCompactList}\item 
void \hyperlink{classPipeline_a027bfee79c81ba2d11829e9116a06159}{setcallback} ()
\begin{DoxyCompactList}\small\item\em Set the inference network to call the callback function as soon as each inference is finished. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
This class is a pipeline class that stores the topology of the input device, output device and networks and make inference. 

Definition at line 27 of file pipeline.\+h.



\subsection{Constructor \& Destructor Documentation}
\index{Pipeline@{Pipeline}!Pipeline@{Pipeline}}
\index{Pipeline@{Pipeline}!Pipeline@{Pipeline}}
\subsubsection[{\texorpdfstring{Pipeline()=default}{Pipeline()=default}}]{\setlength{\rightskip}{0pt plus 5cm}Pipeline\+::\+Pipeline (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [default]}}\hypertarget{classPipeline_a4f65be70dd15f3c0550f6768244098a6}{}\label{classPipeline_a4f65be70dd15f3c0550f6768244098a6}


\subsection{Member Function Documentation}
\index{Pipeline@{Pipeline}!add@{add}}
\index{add@{add}!Pipeline@{Pipeline}}
\subsubsection[{\texorpdfstring{add(const std\+::string \&parent, const std\+::string \&name, std\+::shared\+\_\+ptr$<$ Base\+Input\+Device $>$ input\+\_\+device)}{add(const std::string &parent, const std::string &name, std::shared_ptr< BaseInputDevice > input_device)}}]{\setlength{\rightskip}{0pt plus 5cm}bool Pipeline\+::add (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{parent, }
\item[{const std\+::string \&}]{name, }
\item[{std\+::shared\+\_\+ptr$<$ {\bf Base\+Input\+Device} $>$}]{input\+\_\+device}
\end{DoxyParamCaption}
)}\hypertarget{classPipeline_ad4e6ed704a4dc3df23488a9cf5cf2ae0}{}\label{classPipeline_ad4e6ed704a4dc3df23488a9cf5cf2ae0}


Add input device to the pipeline. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em parent} & name of the parent device of the input device. Should be empty. \\
\hline
\mbox{\tt in}  & {\em name} & name of the current input device. \\
\hline
\mbox{\tt in}  & {\em input\+\_\+device} & the input device instance to be added. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether the add operation is successful 
\end{DoxyReturn}


Definition at line 8 of file pipeline.\+cpp.


\begin{DoxyCode}
9                                                                 \{
10   \textcolor{keywordflow}{if} (!parent.empty()) \{
11     slog::err << \textcolor{stringliteral}{"input device should have no parent!"} << slog::endl;
12     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
13   \}
14   input\_device\_name\_ = name;
15   input\_device\_ = std::move(input\_device);
16   next\_.insert(\{parent, name\});
17   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
18 \};
\end{DoxyCode}
\index{Pipeline@{Pipeline}!add@{add}}
\index{add@{add}!Pipeline@{Pipeline}}
\subsubsection[{\texorpdfstring{add(const std\+::string \&parent, const std\+::string \&name, std\+::shared\+\_\+ptr$<$ openvino\+\_\+service\+::\+Base\+Inference $>$ inference)}{add(const std::string &parent, const std::string &name, std::shared_ptr< openvino_service::BaseInference > inference)}}]{\setlength{\rightskip}{0pt plus 5cm}bool Pipeline\+::add (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{parent, }
\item[{const std\+::string \&}]{name, }
\item[{std\+::shared\+\_\+ptr$<$ {\bf openvino\+\_\+service\+::\+Base\+Inference} $>$}]{inference}
\end{DoxyParamCaption}
)}\hypertarget{classPipeline_ad680458b60d24030e7fe17343ddb6fba}{}\label{classPipeline_ad680458b60d24030e7fe17343ddb6fba}


Add inference network to the pipeline. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em parent} & name of the parent device or inference. \\
\hline
\mbox{\tt in}  & {\em name} & name of the current inference network. \\
\hline
\mbox{\tt in}  & {\em inference} & the inference instance to be added. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether the add operation is successful 
\end{DoxyReturn}


Definition at line 54 of file pipeline.\+cpp.


\begin{DoxyCode}
55                                                                            \{
56   \textcolor{keywordflow}{if} (name\_to\_detection\_map\_.find(parent) == name\_to\_detection\_map\_.end()
57       && input\_device\_name\_ != parent) \{
58     slog::err << \textcolor{stringliteral}{"parent device/detection does not exists!"} << slog::endl;
59     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
60   \}
61   next\_.insert(\{parent, name\});
62   name\_to\_detection\_map\_[name] = std::move(inference);
63   ++total\_detection\_;
64   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
65 \};
\end{DoxyCode}
\index{Pipeline@{Pipeline}!add@{add}}
\index{add@{add}!Pipeline@{Pipeline}}
\subsubsection[{\texorpdfstring{add(const std\+::string \&parent, const std\+::string \&name, std\+::shared\+\_\+ptr$<$ Base\+Output $>$ output)}{add(const std::string &parent, const std::string &name, std::shared_ptr< BaseOutput > output)}}]{\setlength{\rightskip}{0pt plus 5cm}bool Pipeline\+::add (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{parent, }
\item[{const std\+::string \&}]{name, }
\item[{std\+::shared\+\_\+ptr$<$ {\bf Base\+Output} $>$}]{output}
\end{DoxyParamCaption}
)}\hypertarget{classPipeline_a0fea1a0e2a297420afcd1aef773148b6}{}\label{classPipeline_a0fea1a0e2a297420afcd1aef773148b6}


Add output device to the pipeline. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em parent} & name of the parent inference. \\
\hline
\mbox{\tt in}  & {\em name} & name of the current output device. \\
\hline
\mbox{\tt in}  & {\em output} & the output instance to be added. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether the add operation is successful 
\end{DoxyReturn}


Definition at line 20 of file pipeline.\+cpp.


\begin{DoxyCode}
21                                                      \{
22   \textcolor{keywordflow}{if} (parent.empty()) \{
23     slog::err << \textcolor{stringliteral}{"output device have no parent!"} << slog::endl;
24     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
25   \}
26   \textcolor{keywordflow}{if} (name\_to\_detection\_map\_.find(parent) == name\_to\_detection\_map\_.end()) \{
27     slog::err << \textcolor{stringliteral}{"parent detection does not exists!"} << slog::endl;
28     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
29   \}
30   output\_names\_.insert(name);
31   name\_to\_output\_map\_[name] = std::move(output);
32   next\_.insert(\{parent, name\});
33   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
34 \};
\end{DoxyCode}
\index{Pipeline@{Pipeline}!add@{add}}
\index{add@{add}!Pipeline@{Pipeline}}
\subsubsection[{\texorpdfstring{add(const std\+::string \&parent, const std\+::string \&name)}{add(const std::string &parent, const std::string &name)}}]{\setlength{\rightskip}{0pt plus 5cm}bool Pipeline\+::add (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{parent, }
\item[{const std\+::string \&}]{name}
\end{DoxyParamCaption}
)}\hypertarget{classPipeline_a92f954c069e1355df63f753a656ac3ec}{}\label{classPipeline_a92f954c069e1355df63f753a656ac3ec}


Add inference network-\/output device edge to the pipeline. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em parent} & name of the parent inference. \\
\hline
\mbox{\tt in}  & {\em name} & name of the current output device. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether the add operation is successful 
\end{DoxyReturn}


Definition at line 36 of file pipeline.\+cpp.


\begin{DoxyCode}
36                                                                  \{
37   \textcolor{keywordflow}{if} (parent.empty()) \{
38     slog::err << \textcolor{stringliteral}{"output device should have no parent!"} << slog::endl;
39     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
40   \}
41   \textcolor{keywordflow}{if} (name\_to\_detection\_map\_.find(parent) == name\_to\_detection\_map\_.end()) \{
42     slog::err << \textcolor{stringliteral}{"parent detection does not exists!"} << slog::endl;
43     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
44   \}
45   \textcolor{keywordflow}{if} (std::find(output\_names\_.begin(), output\_names\_.end(), name)
46       == output\_names\_.end()) \{
47     slog::err << \textcolor{stringliteral}{"output does not exists!"} << slog::endl;
48     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
49   \}
50   next\_.insert(\{parent, name\});
51   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
52 \}
\end{DoxyCode}
\index{Pipeline@{Pipeline}!callback@{callback}}
\index{callback@{callback}!Pipeline@{Pipeline}}
\subsubsection[{\texorpdfstring{callback(const std\+::string \&detection\+\_\+name)}{callback(const std::string &detection_name)}}]{\setlength{\rightskip}{0pt plus 5cm}void Pipeline\+::callback (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{detection\+\_\+name}
\end{DoxyParamCaption}
)}\hypertarget{classPipeline_ab65d4eafa6081d0eb3daddb372cc04dc}{}\label{classPipeline_ab65d4eafa6081d0eb3daddb372cc04dc}


The callback function provided for all the inference network in the pipeline. 



Definition at line 128 of file pipeline.\+cpp.


\begin{DoxyCode}
128                                                        \{
129   \textcolor{comment}{//slog::info<<"Hello callback"<<slog::endl;}
130   \textcolor{keyword}{auto} detection\_ptr = name\_to\_detection\_map\_[detection\_name];
131   detection\_ptr->fetchResults();
132   \textcolor{comment}{// set output}
133   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} pos = next\_.equal\_range(detection\_name);
134        pos.first != pos.second; ++pos.first) \{
135     std::string next\_name = pos.first->second;
136     \textcolor{comment}{// if next is output, then print}
137     \textcolor{keywordflow}{if} (output\_names\_.find(next\_name) != output\_names\_.end()) \{
138       detection\_ptr->accepts(name\_to\_output\_map\_[next\_name]);
139     \}
140     \textcolor{comment}{// if next is network, set input for next network}
141     \textcolor{keywordflow}{else} \{
142       \textcolor{keyword}{auto} detection\_ptr\_iter = name\_to\_detection\_map\_.find(
143           next\_name);
144       \textcolor{keywordflow}{if} (detection\_ptr\_iter != name\_to\_detection\_map\_.end()) \{
145         \textcolor{keyword}{auto} next\_detection\_ptr = detection\_ptr\_iter->second;
146         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < detection\_ptr->getResultsLength(); ++i) \{
147           \hyperlink{structInferenceResult_1_1Result}{InferenceResult::Result} prev\_result =
148               detection\_ptr->getLocationResult(i);
149           \textcolor{keyword}{auto} clippedRect = prev\_result.\hyperlink{structInferenceResult_1_1Result_a20260cebf785b75132140ab517594660}{location} & cv::Rect(0, 0,
150                                                              width\_,
151                                                              height\_);
152           cv::Mat next\_input = frame(clippedRect);
153           next\_detection\_ptr->enqueue(next\_input, prev\_result.\hyperlink{structInferenceResult_1_1Result_a20260cebf785b75132140ab517594660}{location});
154         \}
155         \textcolor{keywordflow}{if} (detection\_ptr->getResultsLength() > 0) \{
156           ++counter;
157           next\_detection\_ptr->submitRequest();
158         \}
159       \}
160     \}
161   \}
162   std::lock\_guard<std::mutex> lk(counter\_mutex);
163   --counter;
164   cv.notify\_all();
165 \}
\end{DoxyCode}
\index{Pipeline@{Pipeline}!run\+Once@{run\+Once}}
\index{run\+Once@{run\+Once}!Pipeline@{Pipeline}}
\subsubsection[{\texorpdfstring{run\+Once()}{runOnce()}}]{\setlength{\rightskip}{0pt plus 5cm}void Pipeline\+::run\+Once (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classPipeline_a5a2faba72449251db99090c4eaad3e1c}{}\label{classPipeline_a5a2faba72449251db99090c4eaad3e1c}


Do the inference once. Data flow from input device to inference network, then to output device. 



Definition at line 67 of file pipeline.\+cpp.


\begin{DoxyCode}
67                        \{
68   counter = 0;
69   \textcolor{keywordflow}{if} (!input\_device\_->read(&frame)) \{
70     \textcolor{keywordflow}{throw} std::logic\_error(\textcolor{stringliteral}{"Failed to get frame from cv::VideoCapture"});
71   \}
72   width\_ = frame.cols;
73   height\_ = frame.rows;
74   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} &pair: name\_to\_output\_map\_) \{
75     pair.second->feedFrame(frame);
76   \}
77   \textcolor{keyword}{auto} t0 = std::chrono::high\_resolution\_clock::now();
78   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} pos = next\_.equal\_range(input\_device\_name\_);
79        pos.first != pos.second; ++pos.first) \{
80     std::string detection\_name = pos.first->second;
81     \textcolor{keyword}{auto} detection\_ptr = name\_to\_detection\_map\_[detection\_name];
82     detection\_ptr->enqueue(
83         frame, cv::Rect(width\_ / 2, height\_ / 2, width\_, height\_));
84     ++counter;
85     detection\_ptr->submitRequest();
86   \}
87   std::unique\_lock<std::mutex> lock(counter\_mutex);
88   cv.wait(lock, [\textcolor{keyword}{self} = \textcolor{keyword}{this}]() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{self}->counter == 0; \});
89   \textcolor{keyword}{auto} t1 = std::chrono::high\_resolution\_clock::now();
90   \textcolor{keyword}{typedef} std::chrono::duration<double, std::ratio<1, 1000>> ms;
91   \textcolor{comment}{//calculate fps}
92   ms secondDetection = std::chrono::duration\_cast<ms>(t1 - t0);
93   std::ostringstream out;
94   std::string window\_output\_string =
95       \textcolor{stringliteral}{"("} + std::to\_string(1000.f / secondDetection.count()) + \textcolor{stringliteral}{" fps)"};
96   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} &pair : name\_to\_output\_map\_) \{
97     pair.second->handleOutput(window\_output\_string);
98   \}
99 \}
\end{DoxyCode}
\index{Pipeline@{Pipeline}!setcallback@{setcallback}}
\index{setcallback@{setcallback}!Pipeline@{Pipeline}}
\subsubsection[{\texorpdfstring{setcallback()}{setcallback()}}]{\setlength{\rightskip}{0pt plus 5cm}void Pipeline\+::setcallback (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classPipeline_a027bfee79c81ba2d11829e9116a06159}{}\label{classPipeline_a027bfee79c81ba2d11829e9116a06159}


Set the inference network to call the callback function as soon as each inference is finished. 



Definition at line 109 of file pipeline.\+cpp.


\begin{DoxyCode}
109                            \{
110   \textcolor{keywordflow}{if} (!input\_device\_->read(&frame)) \{
111     \textcolor{keywordflow}{throw} std::logic\_error(\textcolor{stringliteral}{"Failed to get frame from cv::VideoCapture"});
112   \}
113   width\_ = frame.cols;
114   height\_ = frame.rows;
115   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} &pair: name\_to\_output\_map\_) \{
116     pair.second->feedFrame(frame);
117   \}
118   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} &pair: name\_to\_detection\_map\_) \{
119     std::string detection\_name = pair.first;
120     std::function<void(void)> callb;
121     callb = [detection\_name, \textcolor{keyword}{self} = \textcolor{keyword}{this}]() \{
122       \textcolor{keyword}{self}->callback(detection\_name);
123       \textcolor{keywordflow}{return};
124     \};
125     pair.second->getEngine()->getRequest()->SetCompletionCallback(callb);
126   \}
127 \}
\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/openvino\+\_\+service/\hyperlink{pipeline_8h}{pipeline.\+h}\item 
lib/\hyperlink{pipeline_8cpp}{pipeline.\+cpp}\end{DoxyCompactItemize}
