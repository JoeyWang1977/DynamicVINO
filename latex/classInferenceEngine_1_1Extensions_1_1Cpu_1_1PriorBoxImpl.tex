\hypertarget{classInferenceEngine_1_1Extensions_1_1Cpu_1_1PriorBoxImpl}{}\section{Inference\+Engine\+:\+:Extensions\+:\+:Cpu\+:\+:Prior\+Box\+Impl Class Reference}
\label{classInferenceEngine_1_1Extensions_1_1Cpu_1_1PriorBoxImpl}\index{Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Prior\+Box\+Impl@{Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Prior\+Box\+Impl}}


Inheritance diagram for Inference\+Engine\+:\+:Extensions\+:\+:Cpu\+:\+:Prior\+Box\+Impl\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=222pt]{classInferenceEngine_1_1Extensions_1_1Cpu_1_1PriorBoxImpl__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for Inference\+Engine\+:\+:Extensions\+:\+:Cpu\+:\+:Prior\+Box\+Impl\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=234pt]{classInferenceEngine_1_1Extensions_1_1Cpu_1_1PriorBoxImpl__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1PriorBoxImpl_a20be25ea0e66288956fe988dcf9a57a2}{Prior\+Box\+Impl} (const C\+N\+N\+Layer $\ast$layer)
\item 
Status\+Code \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1PriorBoxImpl_a24ca1d655fb4044338dc19c41eb0a6fa}{execute} (std\+::vector$<$ Blob\+::\+Ptr $>$ \&inputs, std\+::vector$<$ Blob\+::\+Ptr $>$ \&outputs, Response\+Desc $\ast$resp) noexceptoverride
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}


Definition at line 28 of file ext\+\_\+priorbox.\+cpp.



\subsection{Constructor \& Destructor Documentation}
\index{Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Prior\+Box\+Impl@{Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Prior\+Box\+Impl}!Prior\+Box\+Impl@{Prior\+Box\+Impl}}
\index{Prior\+Box\+Impl@{Prior\+Box\+Impl}!Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Prior\+Box\+Impl@{Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Prior\+Box\+Impl}}
\subsubsection[{\texorpdfstring{Prior\+Box\+Impl(const C\+N\+N\+Layer $\ast$layer)}{PriorBoxImpl(const CNNLayer *layer)}}]{\setlength{\rightskip}{0pt plus 5cm}Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Prior\+Box\+Impl\+::\+Prior\+Box\+Impl (
\begin{DoxyParamCaption}
\item[{const C\+N\+N\+Layer $\ast$}]{layer}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}\hypertarget{classInferenceEngine_1_1Extensions_1_1Cpu_1_1PriorBoxImpl_a20be25ea0e66288956fe988dcf9a57a2}{}\label{classInferenceEngine_1_1Extensions_1_1Cpu_1_1PriorBoxImpl_a20be25ea0e66288956fe988dcf9a57a2}


Definition at line 30 of file ext\+\_\+priorbox.\+cpp.


\begin{DoxyCode}
30                                                 : \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_affff0e8263ca26852ccf71d299d7b06a}{ExtLayerBase}(layer) \{
31         \textcolor{keywordflow}{try} \{
32             \textcolor{keywordflow}{if} (\hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1074cdccacb9e9ca6eec01bbc2f7ca4a}{cnnLayer}.insData.size() != 2 || \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1074cdccacb9e9ca6eec01bbc2f7ca4a}{cnnLayer}.outData.empty())
33                 THROW\_IE\_EXCEPTION << \textcolor{stringliteral}{"Incorrect number of input/output edges!"};
34             \_offset = \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1074cdccacb9e9ca6eec01bbc2f7ca4a}{cnnLayer}.GetParamAsFloat(\textcolor{stringliteral}{"offset"});
35             \_step = \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1074cdccacb9e9ca6eec01bbc2f7ca4a}{cnnLayer}.GetParamAsFloat(\textcolor{stringliteral}{"step"}, 0);
36             \_min\_sizes = \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1074cdccacb9e9ca6eec01bbc2f7ca4a}{cnnLayer}.GetParamAsFloats(\textcolor{stringliteral}{"min\_size"}, \{\});
37             \_max\_sizes = \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1074cdccacb9e9ca6eec01bbc2f7ca4a}{cnnLayer}.GetParamAsFloats(\textcolor{stringliteral}{"max\_size"}, \{\});
38             \_flip = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(\hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1074cdccacb9e9ca6eec01bbc2f7ca4a}{cnnLayer}.GetParamAsInt(\textcolor{stringliteral}{"flip"}));
39             \_clip = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(\hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1074cdccacb9e9ca6eec01bbc2f7ca4a}{cnnLayer}.GetParamAsInt(\textcolor{stringliteral}{"clip"}));
40             \_scale\_all\_sizes = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{bool}\textcolor{keyword}{>}(\hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1074cdccacb9e9ca6eec01bbc2f7ca4a}{cnnLayer}.GetParamAsInt(\textcolor{stringliteral}{"scale\_all\_sizes"}, 1));
41 
42             \textcolor{keywordtype}{bool} exist;
43 
44             \_aspect\_ratios.push\_back(1.0f);
45 
46             \textcolor{keyword}{const} std::vector<float> aspect\_ratios = \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1074cdccacb9e9ca6eec01bbc2f7ca4a}{cnnLayer}.GetParamAsFloats(\textcolor{stringliteral}{"aspect\_ratio"}, \{\});
47 
48             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{float} aspect\_ratio : aspect\_ratios) \{
49                 exist = \textcolor{keyword}{false};
50 
51                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{float} \_aspect\_ratio : \_aspect\_ratios) \{
52                     \textcolor{keywordflow}{if} (fabs(aspect\_ratio - \_aspect\_ratio) < 1e-6) \{
53                         exist = \textcolor{keyword}{true};
54                         \textcolor{keywordflow}{break};
55                     \}
56                 \}
57 
58                 \textcolor{keywordflow}{if} (exist) \{
59                     \textcolor{keywordflow}{continue};
60                 \}
61 
62                 \_aspect\_ratios.push\_back(aspect\_ratio);
63 
64                 \textcolor{keywordflow}{if} (\_flip) \{
65                     \_aspect\_ratios.push\_back(1.0f / aspect\_ratio);
66                 \}
67             \}
68 
69             \textcolor{keywordflow}{if} (\_scale\_all\_sizes) \{
70                 \_num\_priors = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\_aspect\_ratios.size() * \_min\_sizes.size());
71             \} \textcolor{keywordflow}{else} \{
72                 \_num\_priors = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\_aspect\_ratios.size() + \_min\_sizes.size() - 1);
73             \}
74 
75             \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = \_max\_sizes.begin(); it != \_max\_sizes.end(); it++) \{
76                 \_num\_priors += 1;
77             \}
78 
79             \textcolor{keyword}{const} std::vector<float> variance = \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1074cdccacb9e9ca6eec01bbc2f7ca4a}{cnnLayer}.GetParamAsFloats(\textcolor{stringliteral}{"variance"}, \{\});
80 
81             \textcolor{keywordflow}{if} (variance.size() == 1 || variance.size() == 4) \{
82                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{float} i : variance) \{
83                     \textcolor{keywordflow}{if} (i < 0) \{
84                         THROW\_IE\_EXCEPTION << \textcolor{stringliteral}{"Variance must be > 0."};
85                     \}
86 
87                     \_variance.push\_back(i);
88                 \}
89             \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (variance.empty()) \{
90                 \_variance.push\_back(0.1f);
91             \} \textcolor{keywordflow}{else} \{
92                 THROW\_IE\_EXCEPTION << \textcolor{stringliteral}{"Wrong number of variance values. Not less than 1 and more than 4
       variance values."};
93             \}
94 
95             \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a0ac7a6632e95b9500d5246b05b4b0bfa}{addConfig}(\{\{\hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1258a8d209e0249e0b1717618352ddfba8e1bde3c3d303163521522cf1d62f21f}{ConfLayout::ANY}, \textcolor{keyword}{true}\}, \{
      \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1258a8d209e0249e0b1717618352ddfba8e1bde3c3d303163521522cf1d62f21f}{ConfLayout::ANY}, \textcolor{keyword}{true}\}\}, \{\{\hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1258a8d209e0249e0b1717618352ddfba446687ea2db1ada75be5ed053be77f59}{ConfLayout::PLN}, \textcolor{keyword}{true}\}\});
96         \} \textcolor{keywordflow}{catch} (InferenceEngine::details::InferenceEngineException &ex) \{
97             \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_abc78e9b5a79fa339ffd831a5318f71f7}{errorMsg} = ex.what();
98         \}
99     \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Prior\+Box\+Impl@{Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Prior\+Box\+Impl}!execute@{execute}}
\index{execute@{execute}!Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Prior\+Box\+Impl@{Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Prior\+Box\+Impl}}
\subsubsection[{\texorpdfstring{execute(std\+::vector$<$ Blob\+::\+Ptr $>$ \&inputs, std\+::vector$<$ Blob\+::\+Ptr $>$ \&outputs, Response\+Desc $\ast$resp) noexceptoverride}{execute(std::vector< Blob::Ptr > &inputs, std::vector< Blob::Ptr > &outputs, ResponseDesc *resp) noexceptoverride}}]{\setlength{\rightskip}{0pt plus 5cm}Status\+Code Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Prior\+Box\+Impl\+::execute (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ Blob\+::\+Ptr $>$ \&}]{inputs, }
\item[{std\+::vector$<$ Blob\+::\+Ptr $>$ \&}]{outputs, }
\item[{Response\+Desc $\ast$}]{resp}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [noexcept]}}\hypertarget{classInferenceEngine_1_1Extensions_1_1Cpu_1_1PriorBoxImpl_a24ca1d655fb4044338dc19c41eb0a6fa}{}\label{classInferenceEngine_1_1Extensions_1_1Cpu_1_1PriorBoxImpl_a24ca1d655fb4044338dc19c41eb0a6fa}


Definition at line 101 of file ext\+\_\+priorbox.\+cpp.


\begin{DoxyCode}
102                                                              \{
103         \textcolor{keywordflow}{if} (inputs.size() != 2 || outputs.empty()) \{
104             \textcolor{keywordflow}{if} (resp) \{
105                 std::string \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_abc78e9b5a79fa339ffd831a5318f71f7}{errorMsg} = \textcolor{stringliteral}{"Incorrect number of input or output edges!"};
106                 errorMsg.copy(resp->msg, \textcolor{keyword}{sizeof}(resp->msg) - 1);
107             \}
108             \textcolor{keywordflow}{return} GENERAL\_ERROR;
109         \}
110         \textcolor{keyword}{auto}& dataMemPtr = inputs[0];
111         \textcolor{keyword}{auto}& imageMemPtr = inputs[1];
112         \textcolor{keyword}{auto}& dstMemPtr = outputs[0];
113         SizeVector \_data\_dims = dataMemPtr->getTensorDesc().getDims();
114         SizeVector \_image\_dims = imageMemPtr->getTensorDesc().getDims();
115         \textcolor{keyword}{const} \textcolor{keywordtype}{int} W = \_data\_dims[3];
116         \textcolor{keyword}{const} \textcolor{keywordtype}{int} H = \_data\_dims[2];
117         \textcolor{keyword}{const} \textcolor{keywordtype}{int} IW = \_image\_dims[3];
118         \textcolor{keyword}{const} \textcolor{keywordtype}{int} IH = \_image\_dims[2];
119 
120         \textcolor{keyword}{const} \textcolor{keywordtype}{int} OH = dstMemPtr->getTensorDesc().getDims()[2];
121         \textcolor{keyword}{const} \textcolor{keywordtype}{int} OW = (dstMemPtr->getTensorDesc().getDims().size() == 3) ? 1 : dstMemPtr->getTensorDesc().
      getDims()[3];
122 
123         \textcolor{keywordtype}{float} step\_x = 0.0f;
124         \textcolor{keywordtype}{float} step\_y = 0.0f;
125 
126         \textcolor{keywordflow}{if} (\_step == 0) \{
127             step\_x = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(IW) / W;
128             step\_y = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(IH) / H;
129         \} \textcolor{keywordflow}{else} \{
130             step\_x = \_step;
131             step\_y = \_step;
132         \}
133 
134         \textcolor{keywordtype}{float}* dst\_data = dstMemPtr->buffer();
135 
136         \textcolor{keywordtype}{int} dim = H * W * \_num\_priors * 4;
137         \textcolor{keywordtype}{int} idx = 0;
138         \textcolor{keywordtype}{float} center\_x = 0.0f;
139         \textcolor{keywordtype}{float} center\_y = 0.0f;
140 
141         \textcolor{keywordtype}{float} box\_width;
142         \textcolor{keywordtype}{float} box\_height;
143 
144         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} h = 0; h < H; ++h) \{
145             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} w = 0; w < W; ++w) \{
146                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} msIdx = 0; msIdx < \_min\_sizes.size(); msIdx++) \{
147                     \textcolor{keywordflow}{if} (\_step == 0) \{
148                         center\_x = (w + 0.5f) * step\_x;
149                         center\_y = (h + 0.5f) * step\_y;
150                     \} \textcolor{keywordflow}{else} \{
151                         center\_x = (\_offset + w) * \_step;
152                         center\_y = (\_offset + h) * \_step;
153                     \}
154 
155                     box\_width = \_min\_sizes[msIdx];
156                     box\_height = \_min\_sizes[msIdx];
157 
158                     dst\_data[idx++] = (center\_x - box\_width / 2.0f) / IW;
159                     dst\_data[idx++] = (center\_y - box\_height / 2.0f) / IH;
160                     dst\_data[idx++] = (center\_x + box\_width / 2.0f) / IW;
161                     dst\_data[idx++] = (center\_y + box\_height / 2.0f) / IH;
162 
163                     \textcolor{keywordflow}{if} (\_max\_sizes.size() > msIdx) \{
164                         box\_width = box\_height = sqrt(\_min\_sizes[msIdx] * \_max\_sizes[msIdx]);
165 
166                         dst\_data[idx++] = (center\_x - box\_width / 2.0f) / IW;
167                         dst\_data[idx++] = (center\_y - box\_height / 2.0f) / IH;
168                         dst\_data[idx++] = (center\_x + box\_width / 2.0f) / IW;
169                         dst\_data[idx++] = (center\_y + box\_height / 2.0f) / IH;
170                     \}
171 
172                     \textcolor{keywordflow}{if} (\_scale\_all\_sizes || (!\_scale\_all\_sizes && (msIdx == \_min\_sizes.size() - 1))) \{
173                         \textcolor{keywordtype}{size\_t} sIdx = \_scale\_all\_sizes ? msIdx : 0;
174                         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{float} ar : \_aspect\_ratios) \{
175                             \textcolor{keywordflow}{if} (fabs(ar - 1.0f) < 1e-6) \{
176                                 \textcolor{keywordflow}{continue};
177                             \}
178 
179                             box\_width = \_min\_sizes[sIdx] * sqrt(ar);
180                             box\_height = \_min\_sizes[sIdx] / sqrt(ar);
181 
182                             dst\_data[idx++] = (center\_x - box\_width / 2.0f) / IW;
183                             dst\_data[idx++] = (center\_y - box\_height / 2.0f) / IH;
184                             dst\_data[idx++] = (center\_x + box\_width / 2.0f) / IW;
185                             dst\_data[idx++] = (center\_y + box\_height / 2.0f) / IH;
186                         \}
187                     \}
188                 \}
189             \}
190         \}
191 
192         \textcolor{keywordflow}{if} (\_clip) \{
193             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} d = 0; d < dim; ++d) \{
194                 dst\_data[d] = (std::min)((std::max)(dst\_data[d], 0.0f), 1.0f);
195             \}
196         \}
197 
198         \textcolor{keywordtype}{int} channel\_size = OH * OW;
199 
200         dst\_data += channel\_size;
201 
202         \textcolor{keywordtype}{int} count = 0;
203         \textcolor{keywordflow}{if} (\_variance.size() == 1) \{
204             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < channel\_size; i++) \{
205                 dst\_data[i] = \_variance[0];
206             \}
207         \} \textcolor{keywordflow}{else} \{
208             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} h = 0; h < H; ++h) \{
209                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} w = 0; w < W; ++w) \{
210                     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < \_num\_priors; ++i) \{
211                         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < 4; ++j) \{
212                             dst\_data[count] = \_variance[j];
213                             ++count;
214                         \}
215                     \}
216                 \}
217             \}
218         \}
219         \textcolor{keywordflow}{return} OK;
220     \}
\end{DoxyCode}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
thirdparty/extension/\hyperlink{ext__priorbox_8cpp}{ext\+\_\+priorbox.\+cpp}\end{DoxyCompactItemize}
