\hypertarget{classInferenceEngine_1_1Extensions_1_1Cpu_1_1SpatialTransformerImpl}{}\section{Inference\+Engine\+:\+:Extensions\+:\+:Cpu\+:\+:Spatial\+Transformer\+Impl Class Reference}
\label{classInferenceEngine_1_1Extensions_1_1Cpu_1_1SpatialTransformerImpl}\index{Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Spatial\+Transformer\+Impl@{Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Spatial\+Transformer\+Impl}}


Inheritance diagram for Inference\+Engine\+:\+:Extensions\+:\+:Cpu\+:\+:Spatial\+Transformer\+Impl\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=228pt]{classInferenceEngine_1_1Extensions_1_1Cpu_1_1SpatialTransformerImpl__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for Inference\+Engine\+:\+:Extensions\+:\+:Cpu\+:\+:Spatial\+Transformer\+Impl\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=237pt]{classInferenceEngine_1_1Extensions_1_1Cpu_1_1SpatialTransformerImpl__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1SpatialTransformerImpl_ac48a3ac6c003dd3ae05c7cb17ec9e38f}{Spatial\+Transformer\+Impl} (const C\+N\+N\+Layer $\ast$layer)
\item 
Status\+Code \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1SpatialTransformerImpl_a99c1f8a94d598484359684f8c1352f5b}{execute} (std\+::vector$<$ Blob\+::\+Ptr $>$ \&inputs, std\+::vector$<$ Blob\+::\+Ptr $>$ \&outputs, Response\+Desc $\ast$resp) noexceptoverride
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}


Definition at line 30 of file ext\+\_\+spatial\+\_\+transformer.\+cpp.



\subsection{Constructor \& Destructor Documentation}
\index{Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Spatial\+Transformer\+Impl@{Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Spatial\+Transformer\+Impl}!Spatial\+Transformer\+Impl@{Spatial\+Transformer\+Impl}}
\index{Spatial\+Transformer\+Impl@{Spatial\+Transformer\+Impl}!Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Spatial\+Transformer\+Impl@{Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Spatial\+Transformer\+Impl}}
\subsubsection[{\texorpdfstring{Spatial\+Transformer\+Impl(const C\+N\+N\+Layer $\ast$layer)}{SpatialTransformerImpl(const CNNLayer *layer)}}]{\setlength{\rightskip}{0pt plus 5cm}Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Spatial\+Transformer\+Impl\+::\+Spatial\+Transformer\+Impl (
\begin{DoxyParamCaption}
\item[{const C\+N\+N\+Layer $\ast$}]{layer}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}\hypertarget{classInferenceEngine_1_1Extensions_1_1Cpu_1_1SpatialTransformerImpl_ac48a3ac6c003dd3ae05c7cb17ec9e38f}{}\label{classInferenceEngine_1_1Extensions_1_1Cpu_1_1SpatialTransformerImpl_ac48a3ac6c003dd3ae05c7cb17ec9e38f}


Definition at line 32 of file ext\+\_\+spatial\+\_\+transformer.\+cpp.


\begin{DoxyCode}
32                                                           : \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_affff0e8263ca26852ccf71d299d7b06a}{ExtLayerBase}(layer) \{
33         \textcolor{keywordflow}{try} \{
34             \textcolor{keywordflow}{if} (\hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1074cdccacb9e9ca6eec01bbc2f7ca4a}{cnnLayer}.insData.size() != 2 || \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1074cdccacb9e9ca6eec01bbc2f7ca4a}{cnnLayer}.outData.empty())
35                 THROW\_IE\_EXCEPTION << \textcolor{stringliteral}{"Incorrect number of input/output edges!"};
36 
37             \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a0ac7a6632e95b9500d5246b05b4b0bfa}{addConfig}(\{DataConfigurator(\hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1258a8d209e0249e0b1717618352ddfba446687ea2db1ada75be5ed053be77f59}{ConfLayout::PLN}), DataConfigurator(
      \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1258a8d209e0249e0b1717618352ddfba446687ea2db1ada75be5ed053be77f59}{ConfLayout::PLN})\}, \{DataConfigurator(\hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_a1258a8d209e0249e0b1717618352ddfba446687ea2db1ada75be5ed053be77f59}{ConfLayout::PLN})\});
38         \} \textcolor{keywordflow}{catch} (InferenceEngine::details::InferenceEngineException &ex) \{
39             \hyperlink{classInferenceEngine_1_1Extensions_1_1Cpu_1_1ExtLayerBase_abc78e9b5a79fa339ffd831a5318f71f7}{errorMsg} = ex.what();
40         \}
41     \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Spatial\+Transformer\+Impl@{Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Spatial\+Transformer\+Impl}!execute@{execute}}
\index{execute@{execute}!Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Spatial\+Transformer\+Impl@{Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Spatial\+Transformer\+Impl}}
\subsubsection[{\texorpdfstring{execute(std\+::vector$<$ Blob\+::\+Ptr $>$ \&inputs, std\+::vector$<$ Blob\+::\+Ptr $>$ \&outputs, Response\+Desc $\ast$resp) noexceptoverride}{execute(std::vector< Blob::Ptr > &inputs, std::vector< Blob::Ptr > &outputs, ResponseDesc *resp) noexceptoverride}}]{\setlength{\rightskip}{0pt plus 5cm}Status\+Code Inference\+Engine\+::\+Extensions\+::\+Cpu\+::\+Spatial\+Transformer\+Impl\+::execute (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ Blob\+::\+Ptr $>$ \&}]{inputs, }
\item[{std\+::vector$<$ Blob\+::\+Ptr $>$ \&}]{outputs, }
\item[{Response\+Desc $\ast$}]{resp}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [noexcept]}}\hypertarget{classInferenceEngine_1_1Extensions_1_1Cpu_1_1SpatialTransformerImpl_a99c1f8a94d598484359684f8c1352f5b}{}\label{classInferenceEngine_1_1Extensions_1_1Cpu_1_1SpatialTransformerImpl_a99c1f8a94d598484359684f8c1352f5b}


Definition at line 43 of file ext\+\_\+spatial\+\_\+transformer.\+cpp.


\begin{DoxyCode}
44                                                              \{
45         std::vector<size\_t> real\_dims = inputs[0]->getTensorDesc().getDims();
46         \textcolor{keywordtype}{size\_t} data\_size = inputs[0]->size();
47 
48         \textcolor{keyword}{const} \textcolor{keyword}{auto} *src\_data = inputs[0]->cbuffer().as<\textcolor{keyword}{const} \textcolor{keywordtype}{float} *>();
49         \textcolor{keyword}{auto} *theta = inputs[1]->buffer().as<\textcolor{keywordtype}{float} *>();
50         \textcolor{keyword}{auto} *dst\_data = outputs[0]->buffer().as<\textcolor{keywordtype}{float} *>();
51 
52         \textcolor{keyword}{auto} N = real\_dims[0];
53         \textcolor{keyword}{auto} C = real\_dims[1];
54         \textcolor{keyword}{auto} output\_H\_ = real\_dims[2];
55         \textcolor{keyword}{auto} output\_W\_ = real\_dims[3];
56 
57         \textcolor{comment}{// Prepare input and output grid}
58         std::vector<float> input\_grid\_data(N * output\_H\_ * output\_W\_ * 2);
59         std::vector<float> output\_grid\_data(3 * output\_H\_ * output\_W\_);
60         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < output\_H\_ * output\_W\_; ++i) \{
61             output\_grid\_data[3 * i] = (i / output\_W\_) * 1.0 / output\_H\_ * 2 - 1;
62             output\_grid\_data[3 * i + 1] = (i % output\_W\_) * 1.0 / output\_W\_ * 2 - 1;
63             output\_grid\_data[3 * i + 2] = 1;
64         \}
65 
66         \textcolor{comment}{// Actually execute}
67         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < N; ++i) \{
68             \textcolor{keyword}{auto} coordinates = input\_grid\_data.begin() + (output\_H\_ * output\_W\_ * 2) * i;
69 
70             \textcolor{keyword}{auto} M\_size = output\_H\_ * output\_W\_;
71             \textcolor{keyword}{auto} N\_size = 2;
72             \textcolor{keyword}{auto} K\_size = 3;
73 
74             matrixMult(&output\_grid\_data[0], theta + 6 * i, &(*coordinates), M\_size, N\_size, K\_size, \textcolor{keyword}{true});
75 
76             \textcolor{keywordtype}{int} row\_idx;
77             \textcolor{keywordtype}{float} px, py;
78 
79             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < C; ++j) \{
80                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} s = 0; s < output\_H\_; ++s) \{
81                     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} t = 0; t < output\_W\_; ++t) \{
82                         row\_idx = output\_W\_ * s + t;
83 
84                         px = coordinates[row\_idx * 2];
85                         py = coordinates[row\_idx * 2 + 1];
86 
87                         \textcolor{keywordtype}{size\_t} dst\_offset = ((i * C + j) * output\_H\_ + s) * output\_W\_ + t;
88                         \textcolor{keywordtype}{size\_t} src\_offset = ((i * C + j) * output\_H\_ + 0) * output\_W\_ + 0;
89                         dst\_data[dst\_offset] = transform\_forward\_cpu(src\_data + src\_offset, px, py);
90                     \}
91                 \}
92             \}
93         \}
94         \textcolor{keywordflow}{return} OK;
95     \}
\end{DoxyCode}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
thirdparty/extension/\hyperlink{ext__spatial__transformer_8cpp}{ext\+\_\+spatial\+\_\+transformer.\+cpp}\end{DoxyCompactItemize}
